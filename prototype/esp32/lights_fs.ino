#include <WiFi.h>
#include <WebServer.h>
#include <Update.h>
#include <Adafruit_NeoPixel.h>
#include <EEPROM.h>
#include <FS.h>
#include "SPIFFS.h"

#define EEPROM_DATA_SIZE 32
#define EEPROM_TOTAL_SIZE (2 * EEPROM_DATA_SIZE) + 2
#define LED_PIN     15
#define LED_DEFAULT 1000
#define LIGHT_FILE "/l.bin"

const String Version = "0.1.0";
const String DeviceKey = "theoriginallightskey";
const String DeviceID = "OriginalLight1";
const char* ssidAP     = "P-Lights-0";
const char* passwordAP = "defaultpassword";
IPAddress localIP(192, 168, 1, 115);
IPAddress gateway(192, 168, 1, 254);
IPAddress subnet(255, 255, 255, 0);
Adafruit_NeoPixel strip(LED_DEFAULT, LED_PIN, NEO_GRB + NEO_KHZ800);

bool LightStatus = false, LightChange = false;
bool uploading = false, uploaded = false;
WebServer server(80);

IPAddress serverIP;

File fileUpload; 

TaskHandle_t TaskHandler1;
TaskHandle_t TaskHandler2;


// readCreds retrieves credentials from EEPROM, returning a boolean indicating if the credentials exist.
bool readCreds(char ssid[EEPROM_DATA_SIZE], char password[EEPROM_DATA_SIZE]) {

  char ok[2];
  ok[0] = char(EEPROM.read(0 + (EEPROM_DATA_SIZE * 2)));
  ok[1] = char(EEPROM.read(1 + (EEPROM_DATA_SIZE * 2)));
  
  if (ok[0] != 'O' || ok[1] != 'K') {
    return false;
  }
  
  for (int i = 0; i < EEPROM_DATA_SIZE; ++i){
    ssid[i] = char(EEPROM.read(i));
    if (ssid[i] == '\0') {
      break;
    }
  }

  for (int i = 0; i < EEPROM_DATA_SIZE; ++i){
    password[i] = char(EEPROM.read(i + EEPROM_DATA_SIZE));
    if (password[i] == '\0') {
      break;
    }
  }

  return true;
}

bool writeCreds(String ssidS, String passwordS) {

  char ssid[EEPROM_DATA_SIZE];
  char password[EEPROM_DATA_SIZE];

  if (ssidS.length() > EEPROM_DATA_SIZE || passwordS.length() > EEPROM_DATA_SIZE) {
    return false;
  }

  ssidS.toCharArray(ssid, 32);
  passwordS.toCharArray(password, 32);
  
  for (int i = 0; i < ssidS.length(); ++i){
    EEPROM.write(i, ssid[i]);
  }
  EEPROM.write(ssidS.length(), '\0');
  
  for (int i = 0; i < passwordS.length() ; ++i){
    EEPROM.write(i + EEPROM_DATA_SIZE, password[i]);
  }
  EEPROM.write(passwordS.length() + EEPROM_DATA_SIZE, '\0');


  char ok[2];
  EEPROM.write(0 + (EEPROM_DATA_SIZE * 2), 'O');
  EEPROM.write(1 + (EEPROM_DATA_SIZE * 2), 'K');

  EEPROM.commit();
  return true;
}

// startAP creates an AP with the provided ssid and password at the globally configured network.
// startAP then also configures and starts a webserver with routes for connecting to a local network.
void startAP(const char *ssid, const char *password) {

  WiFi.softAPConfig(localIP, gateway, subnet);
  WiFi.softAP(ssid, password);

  IPAddress IP = WiFi.softAPIP();
  Serial.print("AP IP address: ");
  Serial.println(IP);

  server.enableCORS();
  server.on("/", handleIndex);
  server.on("/login", handleLogin);
  server.on("/ip", handleIP);
  server.on("/networks", handleNetwork);

  server.begin();
}

void handleIP() {
    Serial.println("Handler: /ip");
    server.send(200, "text/html", serverIP.toString()); 
}

void handleNetwork() {
  Serial.println("Handler: /networks");

  int n = WiFi.scanNetworks();
   
  String networkJSON = "[";

  for (int i = 0; i < n; ++i) {      
    networkJSON += '"' + WiFi.SSID(i) + '"';
    if (i < n-1) {
      networkJSON += ",";
    }
    delay(10);
  }

  networkJSON += "]";

  server.send(200, "application/json", networkJSON);
  
}

void startServer() {

  server.stop();

  server.on("/dump", handleFileDump);
  server.on("/toggle", handleToggle);
  server.on("/status", handleStatus);
  server.on("/upload",HTTP_POST, []() {
    server.send(200, "text/plain", "");
  }, handleFileUpload);
  server.enableCORS();

  server.begin();
  Serial.println(xPortGetCoreID());

}

String statusJSON(boolean secret) {
    String toggled = LightStatus ? "true" : "false";
    String key = secret ? "" : DeviceKey;
    String json =  "{" 
      "\"status\":"  + toggled + "," +
      "\"ip\":\""  + WiFi.localIP().toString() + "\"," +
      "\"mac\":\""  + WiFi.macAddress() + "\"," + 
      "\"key\":\""  + key + "\"," +
      "\"id\":\"" + DeviceID + "\"," +
      "\"version\":\"" + Version + "\"" +
    "}";
    return json;
}

void handleStatus() {
    Serial.println("Handler: /status");

    String json = statusJSON(true);
    
    server.send(200, "application/json", json);
}

void handleToggle() {

  Serial.println("Handler: /toggle");


  LightStatus = !LightStatus;
  LightChange = true;

  Serial.println("Changed lights status");
  Serial.println(LightStatus);

  server.send(200, "text/html", "OK"); 
}

// handleIndex is a response handler that returns the page generated by the WifiSetup function.
void handleIndex() {
    Serial.println("Handler: /");

  
    server.send(200, "text/html", WifiSetup()); 
}

// startWifi takes the provided ssid and password and attempts to join the network. It will return true once the status is connected or
// after timeout * 500ms it will return false
bool startWiFi(const char * ssid, const char * password, int timeout) {
  Serial.println("Connecting to WIFI");
  
  WiFi.begin(ssid, password);
  Serial.println("");

  int n = 0;
  // Wait for connection
  while (WiFi.status() != WL_CONNECTED && n++ < timeout) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to ");
  Serial.println(ssid);
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  serverIP = WiFi.localIP();
  return WiFi.status() == WL_CONNECTED;
}

// handleLogin is a response handler that reads the query paramters ssid and password then attempts to
// join that network. It will return 200 OK if connected and 500 Not Connected otherwise.
void handleLogin() {
  Serial.println("Handler: /login");

  String ssid = server.arg("ssid");
  String password = server.arg("password");

  if(startWiFi(ssid.c_str(), password.c_str(), 15)) {
    if (writeCreds(ssid, password)) {
      server.send(200, "text/html", "OK");
      ESP.restart();
      return;
    }
  }
  
  server.send(500, "text/html", "Not connected");
  
}

// WifiSetup returns a string containing an HTML page for configuring network SSID and password
// WifiSetup will scan for networks and list the joinable ones in an HTML select field.
String WifiSetup() {

  int n = WiFi.scanNetworks();
   
  String ssids[n];

  for (int i = 0; i < n; ++i) {      
    ssids[i] = WiFi.SSID(i) ;
    delay(10);
  }

  String options = "";
  for (int i = 0; i < n; ++i) {
    options += "<option value=\"" +  ssids[i] + "\">" + ssids[i] + "</option>\n";
  }
  
  return 
"<html>"
" <head></head>"
" <body>"
"   <form action=\"/login\">"
"     <label for=\"wifi\">SSID:</label>"
"     <select name=\"ssid\">" + options +  
"     </select><br><br>"
"     <label for=\"password\">Password:</label>"
"     <input type=\"password\" id=\"password\" name=\"password\"><br><br>"
"     <input type=\"submit\" value=\"Submit\">"
"   </form>"
" </body>"
"</html>";
}


void handleFileDump() {
  Serial.println("Handler: /dump");

  File file = SPIFFS.open(LIGHT_FILE, "r");

  server.streamFile(file, "application/octet-stream");

  file.close();
}

void handleFileUpload(){ 
  Serial.println("Handler: /upload");


  HTTPUpload& upload = server.upload();

  if(upload.status == UPLOAD_FILE_START){
    uploading = true;
    fileUpload = SPIFFS.open(LIGHT_FILE, "w");
  } else if(upload.status == UPLOAD_FILE_WRITE){
    fileUpload.write(upload.buf, upload.currentSize);
  } else if(upload.status == UPLOAD_FILE_END) {
    fileUpload.close();
    uploaded = true;
  } 
}

void serveTime(uint32_t delayAmount){ 

  unsigned long start = millis();

  Serial.println("delaying");

  for(;;) {

    // serve a connection
    server.handleClient();

    // Light status has been changed, the current state of the lights is invalid
    if (LightChange) {
      LightChange = false;
      break;
    }

    // Something new has been uploaded restart the animation
    // Regardless of the wait time
    if (uploaded) {
      uploading = false;
      uploaded = false;
      //Serial.println("uploaded terminating serve");
      break;
    }

    // The amount of delay has expired return to possibly running
    // animiations
    if (millis() > start + delayAmount) {
      //Serial.println("no longer delaying");
      //Serial.println(start);
      //Serial.println(millis());
      //Serial.println(delayAmount);
      //delay(500);
      break;
    }
  }
}



void runInstructions(  Adafruit_NeoPixel * strip){

  strip->clear();

  if (!LightStatus) {
    strip->show();

    // Lights are off. Don't show anything. Give the server
    // time to server as that is the only way this will change
    serveTime(500);
    return;
  }

  if (uploading) {
     // Don't start a new animation while something is being actively uploaded
     serveTime(500);
     return;
  }

  File file = SPIFFS.open(LIGHT_FILE, "r");

  uint8_t buf[8];
  uint16_t index;
  uint32_t delayAmount;
  uint16_t count; 
  uint8_t r, g, b;

  Serial.println("Running instructions");

  uint8_t lastInstruction = 0;

  while (file.available()) {

    if (!LightStatus) {
      strip->clear();
      strip->show();
      break;
    }

    if (uploading) {
      break;
    }
    
    file.read(buf, 8);

    if(buf[0] == 0x3) {
      count = (buf[2] << 8) | buf[1];
      strip->updateLength(count);
      strip->clear();
      //Serial.println("Set Count");
    }else if(buf[0] == 0x2) {
      //Serial.println("Delay");
      delayAmount = (buf[4] << 24) | (buf[3] << 16) | (buf[2] << 8) | buf[1];
      strip->show();
      // While animation is waiting. Run the server
      serveTime(delayAmount);
      
    }else if(buf[0] == 0x1) {
      //Serial.println("color");
      r = buf[1];
      g = buf[2];
      b = buf[3];
      index = (buf[5] << 8) | buf[4];
      strip->setPixelColor(index, strip->Color(g, r, b)); 
    }

    lastInstruction = buf[0];
  }

  if (lastInstruction != 0x2) {
    Serial.println("forced delay");
    serveTime(1000);
  }

  file.close();
}

void setup() {

  
   char ssid[32];
   char password[32]; 

   Serial.begin(115200);
   SPIFFS.begin(false);
   strip.begin(); 
   EEPROM.begin(EEPROM_TOTAL_SIZE);
   
   delay(5000);
   
   bool hasCredentials = readCreds(ssid, password);
   if (hasCredentials) {
       if (startWiFi(ssid, password, 60)) {
           startServer();
       }
   } else {
     WiFi.mode(WIFI_MODE_APSTA);  
     startAP(ssidAP, passwordAP);
   }
}


void loop() {
  runInstructions(&strip);
}
