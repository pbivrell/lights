{"ast":null,"code":"import _classCallCheck from \"/Users/pbivrell/light/light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/pbivrell/light/light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/pbivrell/light/light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/pbivrell/light/light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Util } from '../Util.js';\nimport { Factory } from '../Factory.js';\nimport { Shape } from '../Shape.js';\nimport { Path } from './Path.js';\nimport { Text, stringToArray } from './Text.js';\nimport { getNumberValidator } from '../Validators.js';\nimport { _registerNode } from '../Global.js';\nvar EMPTY_STRING = '',\n    NORMAL = 'normal';\n\nfunction _fillFunc(context) {\n  context.fillText(this.partialText, 0, 0);\n}\n\nfunction _strokeFunc(context) {\n  context.strokeText(this.partialText, 0, 0);\n}\n\nexport var TextPath = /*#__PURE__*/function (_Shape) {\n  _inherits(TextPath, _Shape);\n\n  var _super = _createSuper(TextPath);\n\n  function TextPath(config) {\n    var _this;\n\n    _classCallCheck(this, TextPath);\n\n    _this = _super.call(this, config);\n    _this.dummyCanvas = Util.createCanvasElement();\n    _this.dataArray = [];\n    _this.dataArray = Path.parsePathData(_this.attrs.data);\n\n    _this.on('dataChange.konva', function () {\n      this.dataArray = Path.parsePathData(this.attrs.data);\n\n      this._setTextData();\n    });\n\n    _this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva', _this._setTextData);\n\n    _this._setTextData();\n\n    return _this;\n  }\n\n  _createClass(TextPath, [{\n    key: \"_sceneFunc\",\n    value: function _sceneFunc(context) {\n      context.setAttr('font', this._getContextFont());\n      context.setAttr('textBaseline', this.textBaseline());\n      context.setAttr('textAlign', 'left');\n      context.save();\n      var textDecoration = this.textDecoration();\n      var fill = this.fill();\n      var fontSize = this.fontSize();\n      var glyphInfo = this.glyphInfo;\n\n      if (textDecoration === 'underline') {\n        context.beginPath();\n      }\n\n      for (var i = 0; i < glyphInfo.length; i++) {\n        context.save();\n        var p0 = glyphInfo[i].p0;\n        context.translate(p0.x, p0.y);\n        context.rotate(glyphInfo[i].rotation);\n        this.partialText = glyphInfo[i].text;\n        context.fillStrokeShape(this);\n\n        if (textDecoration === 'underline') {\n          if (i === 0) {\n            context.moveTo(0, fontSize / 2 + 1);\n          }\n\n          context.lineTo(fontSize, fontSize / 2 + 1);\n        }\n\n        context.restore();\n      }\n\n      if (textDecoration === 'underline') {\n        context.strokeStyle = fill;\n        context.lineWidth = fontSize / 20;\n        context.stroke();\n      }\n\n      context.restore();\n    }\n  }, {\n    key: \"_hitFunc\",\n    value: function _hitFunc(context) {\n      context.beginPath();\n      var glyphInfo = this.glyphInfo;\n\n      if (glyphInfo.length >= 1) {\n        var p0 = glyphInfo[0].p0;\n        context.moveTo(p0.x, p0.y);\n      }\n\n      for (var i = 0; i < glyphInfo.length; i++) {\n        var p1 = glyphInfo[i].p1;\n        context.lineTo(p1.x, p1.y);\n      }\n\n      context.setAttr('lineWidth', this.fontSize());\n      context.setAttr('strokeStyle', this.colorKey);\n      context.stroke();\n    }\n  }, {\n    key: \"getTextWidth\",\n    value: function getTextWidth() {\n      return this.textWidth;\n    }\n  }, {\n    key: \"getTextHeight\",\n    value: function getTextHeight() {\n      Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n      return this.textHeight;\n    }\n  }, {\n    key: \"setText\",\n    value: function setText(text) {\n      return Text.prototype.setText.call(this, text);\n    }\n  }, {\n    key: \"_getContextFont\",\n    value: function _getContextFont() {\n      return Text.prototype._getContextFont.call(this);\n    }\n  }, {\n    key: \"_getTextSize\",\n    value: function _getTextSize(text) {\n      var dummyCanvas = this.dummyCanvas;\n\n      var _context = dummyCanvas.getContext('2d');\n\n      _context.save();\n\n      _context.font = this._getContextFont();\n\n      var metrics = _context.measureText(text);\n\n      _context.restore();\n\n      return {\n        width: metrics.width,\n        height: parseInt(this.attrs.fontSize, 10)\n      };\n    }\n  }, {\n    key: \"_setTextData\",\n    value: function _setTextData() {\n      var that = this;\n\n      var size = this._getTextSize(this.attrs.text);\n\n      var letterSpacing = this.letterSpacing();\n      var align = this.align();\n      var kerningFunc = this.kerningFunc();\n      this.textWidth = size.width;\n      this.textHeight = size.height;\n      var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n      this.glyphInfo = [];\n      var fullPathWidth = 0;\n\n      for (var l = 0; l < that.dataArray.length; l++) {\n        if (that.dataArray[l].pathLength > 0) {\n          fullPathWidth += that.dataArray[l].pathLength;\n        }\n      }\n\n      var offset = 0;\n\n      if (align === 'center') {\n        offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n      }\n\n      if (align === 'right') {\n        offset = Math.max(0, fullPathWidth - textFullWidth);\n      }\n\n      var charArr = stringToArray(this.text());\n      var spacesNumber = this.text().split(' ').length - 1;\n      var p0, p1, pathCmd;\n      var pIndex = -1;\n      var currentT = 0;\n\n      var getNextPathSegment = function getNextPathSegment() {\n        currentT = 0;\n        var pathData = that.dataArray;\n\n        for (var j = pIndex + 1; j < pathData.length; j++) {\n          if (pathData[j].pathLength > 0) {\n            pIndex = j;\n            return pathData[j];\n          } else if (pathData[j].command === 'M') {\n            p0 = {\n              x: pathData[j].points[0],\n              y: pathData[j].points[1]\n            };\n          }\n        }\n\n        return {};\n      };\n\n      var findSegmentToFitCharacter = function findSegmentToFitCharacter(c) {\n        var glyphWidth = that._getTextSize(c).width + letterSpacing;\n\n        if (c === ' ' && align === 'justify') {\n          glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n        }\n\n        var currLen = 0;\n        var attempts = 0;\n        p1 = undefined;\n\n        while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 && attempts < 20) {\n          attempts++;\n          var cumulativePathLength = currLen;\n\n          while (pathCmd === undefined) {\n            pathCmd = getNextPathSegment();\n\n            if (pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n              cumulativePathLength += pathCmd.pathLength;\n              pathCmd = undefined;\n            }\n          }\n\n          if (pathCmd === {} || p0 === undefined) {\n            return undefined;\n          }\n\n          var needNewSegment = false;\n\n          switch (pathCmd.command) {\n            case 'L':\n              if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n                p1 = Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n              } else {\n                pathCmd = undefined;\n              }\n\n              break;\n\n            case 'A':\n              var start = pathCmd.points[4];\n              var dTheta = pathCmd.points[5];\n              var end = pathCmd.points[4] + dTheta;\n\n              if (currentT === 0) {\n                currentT = start + 0.00000001;\n              } else if (glyphWidth > currLen) {\n                currentT += Math.PI / 180.0 * dTheta / Math.abs(dTheta);\n              } else {\n                currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);\n              }\n\n              if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n                currentT = end;\n                needNewSegment = true;\n              }\n\n              p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n              break;\n\n            case 'C':\n              if (currentT === 0) {\n                if (glyphWidth > pathCmd.pathLength) {\n                  currentT = 0.00000001;\n                } else {\n                  currentT = glyphWidth / pathCmd.pathLength;\n                }\n              } else if (glyphWidth > currLen) {\n                currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n              } else {\n                currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n              }\n\n              if (currentT > 1.0) {\n                currentT = 1.0;\n                needNewSegment = true;\n              }\n\n              p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n              break;\n\n            case 'Q':\n              if (currentT === 0) {\n                currentT = glyphWidth / pathCmd.pathLength;\n              } else if (glyphWidth > currLen) {\n                currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n              } else {\n                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n              }\n\n              if (currentT > 1.0) {\n                currentT = 1.0;\n                needNewSegment = true;\n              }\n\n              p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n              break;\n          }\n\n          if (p1 !== undefined) {\n            currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n          }\n\n          if (needNewSegment) {\n            needNewSegment = false;\n            pathCmd = undefined;\n          }\n        }\n      };\n\n      var testChar = 'C';\n      var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n      var lettersInOffset = offset / glyphWidth - 1;\n\n      for (var k = 0; k < lettersInOffset; k++) {\n        findSegmentToFitCharacter(testChar);\n\n        if (p0 === undefined || p1 === undefined) {\n          break;\n        }\n\n        p0 = p1;\n      }\n\n      for (var i = 0; i < charArr.length; i++) {\n        findSegmentToFitCharacter(charArr[i]);\n\n        if (p0 === undefined || p1 === undefined) {\n          break;\n        }\n\n        var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n        var kern = 0;\n\n        if (kerningFunc) {\n          try {\n            kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n          } catch (e) {\n            kern = 0;\n          }\n        }\n\n        p0.x += kern;\n        p1.x += kern;\n        this.textWidth += kern;\n        var midpoint = Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n        var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n        this.glyphInfo.push({\n          transposeX: midpoint.x,\n          transposeY: midpoint.y,\n          text: charArr[i],\n          rotation: rotation,\n          p0: p0,\n          p1: p1\n        });\n        p0 = p1;\n      }\n    }\n  }, {\n    key: \"getSelfRect\",\n    value: function getSelfRect() {\n      if (!this.glyphInfo.length) {\n        return {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n\n      var points = [];\n      this.glyphInfo.forEach(function (info) {\n        points.push(info.p0.x);\n        points.push(info.p0.y);\n        points.push(info.p1.x);\n        points.push(info.p1.y);\n      });\n      var minX = points[0] || 0;\n      var maxX = points[0] || 0;\n      var minY = points[1] || 0;\n      var maxY = points[1] || 0;\n      var x, y;\n\n      for (var i = 0; i < points.length / 2; i++) {\n        x = points[i * 2];\n        y = points[i * 2 + 1];\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n      }\n\n      var fontSize = this.fontSize();\n      return {\n        x: minX - fontSize / 2,\n        y: minY - fontSize / 2,\n        width: maxX - minX + fontSize,\n        height: maxY - minY + fontSize\n      };\n    }\n  }]);\n\n  return TextPath;\n}(Shape);\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\n\n_registerNode(TextPath);\n\nFactory.addGetterSetter(TextPath, 'data');\nFactory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory.addGetterSetter(TextPath, 'fontSize', 12, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory.addGetterSetter(TextPath, 'align', 'left');\nFactory.addGetterSetter(TextPath, 'letterSpacing', 0, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory.addGetterSetter(TextPath, 'kerningFunc', null);","map":{"version":3,"sources":["/Users/pbivrell/light/light/node_modules/konva/lib/shapes/TextPath.js"],"names":["Util","Factory","Shape","Path","Text","stringToArray","getNumberValidator","_registerNode","EMPTY_STRING","NORMAL","_fillFunc","context","fillText","partialText","_strokeFunc","strokeText","TextPath","config","dummyCanvas","createCanvasElement","dataArray","parsePathData","attrs","data","on","_setTextData","setAttr","_getContextFont","textBaseline","save","textDecoration","fill","fontSize","glyphInfo","beginPath","i","length","p0","translate","x","y","rotate","rotation","text","fillStrokeShape","moveTo","lineTo","restore","strokeStyle","lineWidth","stroke","p1","colorKey","textWidth","warn","textHeight","prototype","setText","call","_context","getContext","font","metrics","measureText","width","height","parseInt","that","size","_getTextSize","letterSpacing","align","kerningFunc","textFullWidth","Math","max","fullPathWidth","l","pathLength","offset","charArr","spacesNumber","split","pathCmd","pIndex","currentT","getNextPathSegment","pathData","j","command","points","findSegmentToFitCharacter","c","glyphWidth","currLen","attempts","undefined","abs","cumulativePathLength","needNewSegment","getLineLength","getPointOnLine","start","dTheta","end","PI","getPointOnEllipticalArc","getPointOnCubicBezier","getPointOnQuadraticBezier","testChar","lettersInOffset","k","kern","e","midpoint","atan2","push","transposeX","transposeY","forEach","info","minX","maxX","minY","maxY","min","_fillFuncHit","_strokeFuncHit","className","_attrsAffectingSize","addGetterSetter"],"mappings":"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","sourcesContent":["import { Util } from '../Util.js';\nimport { Factory } from '../Factory.js';\nimport { Shape } from '../Shape.js';\nimport { Path } from './Path.js';\nimport { Text, stringToArray } from './Text.js';\nimport { getNumberValidator } from '../Validators.js';\nimport { _registerNode } from '../Global.js';\nvar EMPTY_STRING = '', NORMAL = 'normal';\nfunction _fillFunc(context) {\n    context.fillText(this.partialText, 0, 0);\n}\nfunction _strokeFunc(context) {\n    context.strokeText(this.partialText, 0, 0);\n}\nexport class TextPath extends Shape {\n    constructor(config) {\n        super(config);\n        this.dummyCanvas = Util.createCanvasElement();\n        this.dataArray = [];\n        this.dataArray = Path.parsePathData(this.attrs.data);\n        this.on('dataChange.konva', function () {\n            this.dataArray = Path.parsePathData(this.attrs.data);\n            this._setTextData();\n        });\n        this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva', this._setTextData);\n        this._setTextData();\n    }\n    _sceneFunc(context) {\n        context.setAttr('font', this._getContextFont());\n        context.setAttr('textBaseline', this.textBaseline());\n        context.setAttr('textAlign', 'left');\n        context.save();\n        var textDecoration = this.textDecoration();\n        var fill = this.fill();\n        var fontSize = this.fontSize();\n        var glyphInfo = this.glyphInfo;\n        if (textDecoration === 'underline') {\n            context.beginPath();\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            context.save();\n            var p0 = glyphInfo[i].p0;\n            context.translate(p0.x, p0.y);\n            context.rotate(glyphInfo[i].rotation);\n            this.partialText = glyphInfo[i].text;\n            context.fillStrokeShape(this);\n            if (textDecoration === 'underline') {\n                if (i === 0) {\n                    context.moveTo(0, fontSize / 2 + 1);\n                }\n                context.lineTo(fontSize, fontSize / 2 + 1);\n            }\n            context.restore();\n        }\n        if (textDecoration === 'underline') {\n            context.strokeStyle = fill;\n            context.lineWidth = fontSize / 20;\n            context.stroke();\n        }\n        context.restore();\n    }\n    _hitFunc(context) {\n        context.beginPath();\n        var glyphInfo = this.glyphInfo;\n        if (glyphInfo.length >= 1) {\n            var p0 = glyphInfo[0].p0;\n            context.moveTo(p0.x, p0.y);\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            var p1 = glyphInfo[i].p1;\n            context.lineTo(p1.x, p1.y);\n        }\n        context.setAttr('lineWidth', this.fontSize());\n        context.setAttr('strokeStyle', this.colorKey);\n        context.stroke();\n    }\n    getTextWidth() {\n        return this.textWidth;\n    }\n    getTextHeight() {\n        Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n        return this.textHeight;\n    }\n    setText(text) {\n        return Text.prototype.setText.call(this, text);\n    }\n    _getContextFont() {\n        return Text.prototype._getContextFont.call(this);\n    }\n    _getTextSize(text) {\n        var dummyCanvas = this.dummyCanvas;\n        var _context = dummyCanvas.getContext('2d');\n        _context.save();\n        _context.font = this._getContextFont();\n        var metrics = _context.measureText(text);\n        _context.restore();\n        return {\n            width: metrics.width,\n            height: parseInt(this.attrs.fontSize, 10),\n        };\n    }\n    _setTextData() {\n        var that = this;\n        var size = this._getTextSize(this.attrs.text);\n        var letterSpacing = this.letterSpacing();\n        var align = this.align();\n        var kerningFunc = this.kerningFunc();\n        this.textWidth = size.width;\n        this.textHeight = size.height;\n        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n        this.glyphInfo = [];\n        var fullPathWidth = 0;\n        for (var l = 0; l < that.dataArray.length; l++) {\n            if (that.dataArray[l].pathLength > 0) {\n                fullPathWidth += that.dataArray[l].pathLength;\n            }\n        }\n        var offset = 0;\n        if (align === 'center') {\n            offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n        }\n        if (align === 'right') {\n            offset = Math.max(0, fullPathWidth - textFullWidth);\n        }\n        var charArr = stringToArray(this.text());\n        var spacesNumber = this.text().split(' ').length - 1;\n        var p0, p1, pathCmd;\n        var pIndex = -1;\n        var currentT = 0;\n        var getNextPathSegment = function () {\n            currentT = 0;\n            var pathData = that.dataArray;\n            for (var j = pIndex + 1; j < pathData.length; j++) {\n                if (pathData[j].pathLength > 0) {\n                    pIndex = j;\n                    return pathData[j];\n                }\n                else if (pathData[j].command === 'M') {\n                    p0 = {\n                        x: pathData[j].points[0],\n                        y: pathData[j].points[1],\n                    };\n                }\n            }\n            return {};\n        };\n        var findSegmentToFitCharacter = function (c) {\n            var glyphWidth = that._getTextSize(c).width + letterSpacing;\n            if (c === ' ' && align === 'justify') {\n                glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n            }\n            var currLen = 0;\n            var attempts = 0;\n            p1 = undefined;\n            while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&\n                attempts < 20) {\n                attempts++;\n                var cumulativePathLength = currLen;\n                while (pathCmd === undefined) {\n                    pathCmd = getNextPathSegment();\n                    if (pathCmd &&\n                        cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n                        cumulativePathLength += pathCmd.pathLength;\n                        pathCmd = undefined;\n                    }\n                }\n                if (pathCmd === {} || p0 === undefined) {\n                    return undefined;\n                }\n                var needNewSegment = false;\n                switch (pathCmd.command) {\n                    case 'L':\n                        if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n                            p1 = Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n                        }\n                        else {\n                            pathCmd = undefined;\n                        }\n                        break;\n                    case 'A':\n                        var start = pathCmd.points[4];\n                        var dTheta = pathCmd.points[5];\n                        var end = pathCmd.points[4] + dTheta;\n                        if (currentT === 0) {\n                            currentT = start + 0.00000001;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += ((Math.PI / 180.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        else {\n                            currentT -= ((Math.PI / 360.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        if ((dTheta < 0 && currentT < end) ||\n                            (dTheta >= 0 && currentT > end)) {\n                            currentT = end;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n                        break;\n                    case 'C':\n                        if (currentT === 0) {\n                            if (glyphWidth > pathCmd.pathLength) {\n                                currentT = 0.00000001;\n                            }\n                            else {\n                                currentT = glyphWidth / pathCmd.pathLength;\n                            }\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n                        }\n                        else {\n                            currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n                        break;\n                    case 'Q':\n                        if (currentT === 0) {\n                            currentT = glyphWidth / pathCmd.pathLength;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n                        }\n                        else {\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n                        break;\n                }\n                if (p1 !== undefined) {\n                    currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                }\n                if (needNewSegment) {\n                    needNewSegment = false;\n                    pathCmd = undefined;\n                }\n            }\n        };\n        var testChar = 'C';\n        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n        var lettersInOffset = offset / glyphWidth - 1;\n        for (var k = 0; k < lettersInOffset; k++) {\n            findSegmentToFitCharacter(testChar);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            p0 = p1;\n        }\n        for (var i = 0; i < charArr.length; i++) {\n            findSegmentToFitCharacter(charArr[i]);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n            var kern = 0;\n            if (kerningFunc) {\n                try {\n                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n                }\n                catch (e) {\n                    kern = 0;\n                }\n            }\n            p0.x += kern;\n            p1.x += kern;\n            this.textWidth += kern;\n            var midpoint = Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n            var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n            this.glyphInfo.push({\n                transposeX: midpoint.x,\n                transposeY: midpoint.y,\n                text: charArr[i],\n                rotation: rotation,\n                p0: p0,\n                p1: p1,\n            });\n            p0 = p1;\n        }\n    }\n    getSelfRect() {\n        if (!this.glyphInfo.length) {\n            return {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0,\n            };\n        }\n        var points = [];\n        this.glyphInfo.forEach(function (info) {\n            points.push(info.p0.x);\n            points.push(info.p0.y);\n            points.push(info.p1.x);\n            points.push(info.p1.y);\n        });\n        var minX = points[0] || 0;\n        var maxX = points[0] || 0;\n        var minY = points[1] || 0;\n        var maxY = points[1] || 0;\n        var x, y;\n        for (var i = 0; i < points.length / 2; i++) {\n            x = points[i * 2];\n            y = points[i * 2 + 1];\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        }\n        var fontSize = this.fontSize();\n        return {\n            x: minX - fontSize / 2,\n            y: minY - fontSize / 2,\n            width: maxX - minX + fontSize,\n            height: maxY - minY + fontSize,\n        };\n    }\n}\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\n_registerNode(TextPath);\nFactory.addGetterSetter(TextPath, 'data');\nFactory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory.addGetterSetter(TextPath, 'fontSize', 12, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory.addGetterSetter(TextPath, 'align', 'left');\nFactory.addGetterSetter(TextPath, 'letterSpacing', 0, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory.addGetterSetter(TextPath, 'kerningFunc', null);\n"]},"metadata":{},"sourceType":"module"}