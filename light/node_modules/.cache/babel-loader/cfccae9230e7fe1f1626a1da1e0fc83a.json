{"ast":null,"code":"import _classCallCheck from \"/Users/pbivrell/light/light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/pbivrell/light/light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/pbivrell/light/light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/pbivrell/light/light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/pbivrell/light/light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Konva } from './Global.js';\nimport { Transform, Util } from './Util.js';\nimport { Factory } from './Factory.js';\nimport { Node } from './Node.js';\nimport { getNumberValidator, getNumberOrAutoValidator, getStringValidator, getBooleanValidator, getStringOrGradientValidator } from './Validators.js';\nimport { _registerNode } from './Global.js';\nimport * as PointerEvents from './PointerEvents.js';\nvar HAS_SHADOW = 'hasShadow';\nvar SHADOW_RGBA = 'shadowRGBA';\nvar patternImage = 'patternImage';\nvar linearGradient = 'linearGradient';\nvar radialGradient = 'radialGradient';\nvar dummyContext;\n\nfunction getDummyContext() {\n  if (dummyContext) {\n    return dummyContext;\n  }\n\n  dummyContext = Util.createCanvasElement().getContext('2d');\n  return dummyContext;\n}\n\nexport var shapes = {};\n\nfunction _fillFunc(context) {\n  context.fill();\n}\n\nfunction _strokeFunc(context) {\n  context.stroke();\n}\n\nfunction _fillFuncHit(context) {\n  context.fill();\n}\n\nfunction _strokeFuncHit(context) {\n  context.stroke();\n}\n\nfunction _clearHasShadowCache() {\n  this._clearCache(HAS_SHADOW);\n}\n\nfunction _clearGetShadowRGBACache() {\n  this._clearCache(SHADOW_RGBA);\n}\n\nfunction _clearFillPatternCache() {\n  this._clearCache(patternImage);\n}\n\nfunction _clearLinearGradientCache() {\n  this._clearCache(linearGradient);\n}\n\nfunction _clearRadialGradientCache() {\n  this._clearCache(radialGradient);\n}\n\nexport var Shape = /*#__PURE__*/function (_Node) {\n  _inherits(Shape, _Node);\n\n  var _super = _createSuper(Shape);\n\n  function Shape(config) {\n    var _this;\n\n    _classCallCheck(this, Shape);\n\n    _this = _super.call(this, config);\n    var key;\n\n    while (true) {\n      key = Util.getRandomColor();\n\n      if (key && !(key in shapes)) {\n        break;\n      }\n    }\n\n    _this.colorKey = key;\n    shapes[key] = _assertThisInitialized(_this);\n    return _this;\n  }\n\n  _createClass(Shape, [{\n    key: \"getContext\",\n    value: function getContext() {\n      Util.warn('shape.getContext() method is deprecated. Please do not use it.');\n      return this.getLayer().getContext();\n    }\n  }, {\n    key: \"getCanvas\",\n    value: function getCanvas() {\n      Util.warn('shape.getCanvas() method is deprecated. Please do not use it.');\n      return this.getLayer().getCanvas();\n    }\n  }, {\n    key: \"getSceneFunc\",\n    value: function getSceneFunc() {\n      return this.attrs.sceneFunc || this['_sceneFunc'];\n    }\n  }, {\n    key: \"getHitFunc\",\n    value: function getHitFunc() {\n      return this.attrs.hitFunc || this['_hitFunc'];\n    }\n  }, {\n    key: \"hasShadow\",\n    value: function hasShadow() {\n      return this._getCache(HAS_SHADOW, this._hasShadow);\n    }\n  }, {\n    key: \"_hasShadow\",\n    value: function _hasShadow() {\n      return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY());\n    }\n  }, {\n    key: \"_getFillPattern\",\n    value: function _getFillPattern() {\n      return this._getCache(patternImage, this.__getFillPattern);\n    }\n  }, {\n    key: \"__getFillPattern\",\n    value: function __getFillPattern() {\n      if (this.fillPatternImage()) {\n        var ctx = getDummyContext();\n        var pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || 'repeat');\n\n        if (pattern && pattern.setTransform) {\n          var tr = new Transform();\n          tr.translate(this.fillPatternX(), this.fillPatternY());\n          tr.rotate(Konva.getAngle(this.fillPatternRotation()));\n          tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());\n          tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());\n          var m = tr.getMatrix();\n          pattern.setTransform({\n            a: m[0],\n            b: m[1],\n            c: m[2],\n            d: m[3],\n            e: m[4],\n            f: m[5]\n          });\n        }\n\n        return pattern;\n      }\n    }\n  }, {\n    key: \"_getLinearGradient\",\n    value: function _getLinearGradient() {\n      return this._getCache(linearGradient, this.__getLinearGradient);\n    }\n  }, {\n    key: \"__getLinearGradient\",\n    value: function __getLinearGradient() {\n      var colorStops = this.fillLinearGradientColorStops();\n\n      if (colorStops) {\n        var ctx = getDummyContext();\n        var start = this.fillLinearGradientStartPoint();\n        var end = this.fillLinearGradientEndPoint();\n        var grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\n\n        for (var n = 0; n < colorStops.length; n += 2) {\n          grd.addColorStop(colorStops[n], colorStops[n + 1]);\n        }\n\n        return grd;\n      }\n    }\n  }, {\n    key: \"_getRadialGradient\",\n    value: function _getRadialGradient() {\n      return this._getCache(radialGradient, this.__getRadialGradient);\n    }\n  }, {\n    key: \"__getRadialGradient\",\n    value: function __getRadialGradient() {\n      var colorStops = this.fillRadialGradientColorStops();\n\n      if (colorStops) {\n        var ctx = getDummyContext();\n        var start = this.fillRadialGradientStartPoint();\n        var end = this.fillRadialGradientEndPoint();\n        var grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());\n\n        for (var n = 0; n < colorStops.length; n += 2) {\n          grd.addColorStop(colorStops[n], colorStops[n + 1]);\n        }\n\n        return grd;\n      }\n    }\n  }, {\n    key: \"getShadowRGBA\",\n    value: function getShadowRGBA() {\n      return this._getCache(SHADOW_RGBA, this._getShadowRGBA);\n    }\n  }, {\n    key: \"_getShadowRGBA\",\n    value: function _getShadowRGBA() {\n      if (this.hasShadow()) {\n        var rgba = Util.colorToRGBA(this.shadowColor());\n        return 'rgba(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ',' + rgba.a * (this.shadowOpacity() || 1) + ')';\n      }\n    }\n  }, {\n    key: \"hasFill\",\n    value: function hasFill() {\n      var _this2 = this;\n\n      return this._calculate('hasFill', ['fillEnabled', 'fill', 'fillPatternImage', 'fillLinearGradientColorStops', 'fillRadialGradientColorStops'], function () {\n        return _this2.fillEnabled() && !!(_this2.fill() || _this2.fillPatternImage() || _this2.fillLinearGradientColorStops() || _this2.fillRadialGradientColorStops());\n      });\n    }\n  }, {\n    key: \"hasStroke\",\n    value: function hasStroke() {\n      var _this3 = this;\n\n      return this._calculate('hasStroke', ['strokeEnabled', 'strokeWidth', 'stroke', 'strokeLinearGradientColorStops'], function () {\n        return _this3.strokeEnabled() && _this3.strokeWidth() && !!(_this3.stroke() || _this3.strokeLinearGradientColorStops());\n      });\n    }\n  }, {\n    key: \"hasHitStroke\",\n    value: function hasHitStroke() {\n      var width = this.hitStrokeWidth();\n\n      if (width === 'auto') {\n        return this.hasStroke();\n      }\n\n      return this.strokeEnabled() && !!width;\n    }\n  }, {\n    key: \"intersects\",\n    value: function intersects(point) {\n      var stage = this.getStage(),\n          bufferHitCanvas = stage.bufferHitCanvas,\n          p;\n      bufferHitCanvas.getContext().clear();\n      this.drawHit(bufferHitCanvas, null, true);\n      p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;\n      return p[3] > 0;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      Node.prototype.destroy.call(this);\n      delete shapes[this.colorKey];\n      delete this.colorKey;\n      return this;\n    }\n  }, {\n    key: \"_useBufferCanvas\",\n    value: function _useBufferCanvas(forceFill) {\n      var _a;\n\n      if (!this.getStage()) {\n        return false;\n      }\n\n      var perfectDrawEnabled = (_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : true;\n\n      if (!perfectDrawEnabled) {\n        return false;\n      }\n\n      var hasFill = forceFill || this.hasFill();\n      var hasStroke = this.hasStroke();\n      var isTransparent = this.getAbsoluteOpacity() !== 1;\n\n      if (hasFill && hasStroke && isTransparent) {\n        return true;\n      }\n\n      var hasShadow = this.hasShadow();\n      var strokeForShadow = this.shadowForStrokeEnabled();\n\n      if (hasFill && hasStroke && hasShadow && strokeForShadow) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"setStrokeHitEnabled\",\n    value: function setStrokeHitEnabled(val) {\n      Util.warn('strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.');\n\n      if (val) {\n        this.hitStrokeWidth('auto');\n      } else {\n        this.hitStrokeWidth(0);\n      }\n    }\n  }, {\n    key: \"getStrokeHitEnabled\",\n    value: function getStrokeHitEnabled() {\n      if (this.hitStrokeWidth() === 0) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: \"getSelfRect\",\n    value: function getSelfRect() {\n      var size = this.size();\n      return {\n        x: this._centroid ? -size.width / 2 : 0,\n        y: this._centroid ? -size.height / 2 : 0,\n        width: size.width,\n        height: size.height\n      };\n    }\n  }, {\n    key: \"getClientRect\",\n    value: function getClientRect() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var skipTransform = config.skipTransform;\n      var relativeTo = config.relativeTo;\n      var fillRect = this.getSelfRect();\n      var applyStroke = !config.skipStroke && this.hasStroke();\n      var strokeWidth = applyStroke && this.strokeWidth() || 0;\n      var fillAndStrokeWidth = fillRect.width + strokeWidth;\n      var fillAndStrokeHeight = fillRect.height + strokeWidth;\n      var applyShadow = !config.skipShadow && this.hasShadow();\n      var shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;\n      var shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;\n      var preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);\n      var preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);\n      var blurRadius = applyShadow && this.shadowBlur() || 0;\n      var width = preWidth + blurRadius * 2;\n      var height = preHeight + blurRadius * 2;\n      var roundingOffset = 0;\n\n      if (Math.round(strokeWidth / 2) !== strokeWidth / 2) {\n        roundingOffset = 1;\n      }\n\n      var rect = {\n        width: width + roundingOffset,\n        height: height + roundingOffset,\n        x: -Math.round(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetX, 0) + fillRect.x,\n        y: -Math.round(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetY, 0) + fillRect.y\n      };\n\n      if (!skipTransform) {\n        return this._transformedRect(rect, relativeTo);\n      }\n\n      return rect;\n    }\n  }, {\n    key: \"drawScene\",\n    value: function drawScene(can, top) {\n      var layer = this.getLayer(),\n          canvas = can || layer.getCanvas(),\n          context = canvas.getContext(),\n          cachedCanvas = this._getCanvasCache(),\n          drawFunc = this.getSceneFunc(),\n          hasShadow = this.hasShadow(),\n          stage,\n          bufferCanvas,\n          bufferContext;\n\n      var skipBuffer = canvas.isCache;\n      var cachingSelf = top === this;\n\n      if (!this.isVisible() && !cachingSelf) {\n        return this;\n      }\n\n      if (cachedCanvas) {\n        context.save();\n        var m = this.getAbsoluteTransform(top).getMatrix();\n        context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n\n        this._drawCachedSceneCanvas(context);\n\n        context.restore();\n        return this;\n      }\n\n      if (!drawFunc) {\n        return this;\n      }\n\n      context.save();\n\n      if (this._useBufferCanvas() && !skipBuffer) {\n        stage = this.getStage();\n        bufferCanvas = stage.bufferCanvas;\n        bufferContext = bufferCanvas.getContext();\n        bufferContext.clear();\n        bufferContext.save();\n\n        bufferContext._applyLineJoin(this);\n\n        var o = this.getAbsoluteTransform(top).getMatrix();\n        bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n        drawFunc.call(this, bufferContext, this);\n        bufferContext.restore();\n        var ratio = bufferCanvas.pixelRatio;\n\n        if (hasShadow) {\n          context._applyShadow(this);\n        }\n\n        context._applyOpacity(this);\n\n        context._applyGlobalCompositeOperation(this);\n\n        context.drawImage(bufferCanvas._canvas, 0, 0, bufferCanvas.width / ratio, bufferCanvas.height / ratio);\n      } else {\n        context._applyLineJoin(this);\n\n        if (!cachingSelf) {\n          var o = this.getAbsoluteTransform(top).getMatrix();\n          context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n\n          context._applyOpacity(this);\n\n          context._applyGlobalCompositeOperation(this);\n        }\n\n        if (hasShadow) {\n          context._applyShadow(this);\n        }\n\n        drawFunc.call(this, context, this);\n      }\n\n      context.restore();\n      return this;\n    }\n  }, {\n    key: \"drawHit\",\n    value: function drawHit(can, top) {\n      var skipDragCheck = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (!this.shouldDrawHit(top, skipDragCheck)) {\n        return this;\n      }\n\n      var layer = this.getLayer(),\n          canvas = can || layer.hitCanvas,\n          context = canvas && canvas.getContext(),\n          drawFunc = this.hitFunc() || this.sceneFunc(),\n          cachedCanvas = this._getCanvasCache(),\n          cachedHitCanvas = cachedCanvas && cachedCanvas.hit;\n\n      if (!this.colorKey) {\n        Util.warn('Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()');\n      }\n\n      if (cachedHitCanvas) {\n        context.save();\n        var m = this.getAbsoluteTransform(top).getMatrix();\n        context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n\n        this._drawCachedHitCanvas(context);\n\n        context.restore();\n        return this;\n      }\n\n      if (!drawFunc) {\n        return this;\n      }\n\n      context.save();\n\n      context._applyLineJoin(this);\n\n      var selfCache = this === top;\n\n      if (!selfCache) {\n        var o = this.getAbsoluteTransform(top).getMatrix();\n        context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n      }\n\n      drawFunc.call(this, context, this);\n      context.restore();\n      return this;\n    }\n  }, {\n    key: \"drawHitFromCache\",\n    value: function drawHitFromCache() {\n      var alphaThreshold = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      var cachedCanvas = this._getCanvasCache(),\n          sceneCanvas = this._getCachedSceneCanvas(),\n          hitCanvas = cachedCanvas.hit,\n          hitContext = hitCanvas.getContext(),\n          hitWidth = hitCanvas.getWidth(),\n          hitHeight = hitCanvas.getHeight(),\n          hitImageData,\n          hitData,\n          len,\n          rgbColorKey,\n          i,\n          alpha;\n\n      hitContext.clear();\n      hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);\n\n      try {\n        hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);\n        hitData = hitImageData.data;\n        len = hitData.length;\n        rgbColorKey = Util._hexToRgb(this.colorKey);\n\n        for (i = 0; i < len; i += 4) {\n          alpha = hitData[i + 3];\n\n          if (alpha > alphaThreshold) {\n            hitData[i] = rgbColorKey.r;\n            hitData[i + 1] = rgbColorKey.g;\n            hitData[i + 2] = rgbColorKey.b;\n            hitData[i + 3] = 255;\n          } else {\n            hitData[i + 3] = 0;\n          }\n        }\n\n        hitContext.putImageData(hitImageData, 0, 0);\n      } catch (e) {\n        Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"hasPointerCapture\",\n    value: function hasPointerCapture(pointerId) {\n      return PointerEvents.hasPointerCapture(pointerId, this);\n    }\n  }, {\n    key: \"setPointerCapture\",\n    value: function setPointerCapture(pointerId) {\n      PointerEvents.setPointerCapture(pointerId, this);\n    }\n  }, {\n    key: \"releaseCapture\",\n    value: function releaseCapture(pointerId) {\n      PointerEvents.releaseCapture(pointerId, this);\n    }\n  }]);\n\n  return Shape;\n}(Node);\nShape.prototype._fillFunc = _fillFunc;\nShape.prototype._strokeFunc = _strokeFunc;\nShape.prototype._fillFuncHit = _fillFuncHit;\nShape.prototype._strokeFuncHit = _strokeFuncHit;\nShape.prototype._centroid = false;\nShape.prototype.nodeType = 'Shape';\n\n_registerNode(Shape);\n\nShape.prototype.eventListeners = {};\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva', _clearFillPatternCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva', _clearLinearGradientCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva', _clearRadialGradientCache);\nFactory.addGetterSetter(Shape, 'stroke', undefined, getStringOrGradientValidator());\nFactory.addGetterSetter(Shape, 'strokeWidth', 2, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillAfterStrokeEnabled', false);\nFactory.addGetterSetter(Shape, 'hitStrokeWidth', 'auto', getNumberOrAutoValidator());\nFactory.addGetterSetter(Shape, 'strokeHitEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'perfectDrawEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'shadowForStrokeEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'lineJoin');\nFactory.addGetterSetter(Shape, 'lineCap');\nFactory.addGetterSetter(Shape, 'sceneFunc');\nFactory.addGetterSetter(Shape, 'hitFunc');\nFactory.addGetterSetter(Shape, 'dash');\nFactory.addGetterSetter(Shape, 'dashOffset', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowColor', undefined, getStringValidator());\nFactory.addGetterSetter(Shape, 'shadowBlur', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowOpacity', 1, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'shadowOffset', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'shadowOffsetX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowOffsetY', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternImage');\nFactory.addGetterSetter(Shape, 'fill', undefined, getStringOrGradientValidator());\nFactory.addGetterSetter(Shape, 'fillPatternX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternY', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillLinearGradientColorStops');\nFactory.addGetterSetter(Shape, 'strokeLinearGradientColorStops');\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartRadius', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndRadius', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientColorStops');\nFactory.addGetterSetter(Shape, 'fillPatternRepeat', 'repeat');\nFactory.addGetterSetter(Shape, 'fillEnabled', true);\nFactory.addGetterSetter(Shape, 'strokeEnabled', true);\nFactory.addGetterSetter(Shape, 'shadowEnabled', true);\nFactory.addGetterSetter(Shape, 'dashEnabled', true);\nFactory.addGetterSetter(Shape, 'strokeScaleEnabled', true);\nFactory.addGetterSetter(Shape, 'fillPriority', 'color');\nFactory.addComponentsGetterSetter(Shape, 'fillPatternOffset', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillPatternOffsetX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternOffsetY', 0, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'fillPatternScale', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillPatternScaleX', 1, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternScaleY', 1, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientStartPoint', ['x', 'y']);\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientStartPoint', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointY', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientEndPoint', ['x', 'y']);\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientEndPoint', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointY', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientStartPoint', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientEndPoint', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointY', 0);\nFactory.addGetterSetter(Shape, 'fillPatternRotation', 0);\nFactory.backCompat(Shape, {\n  dashArray: 'dash',\n  getDashArray: 'getDash',\n  setDashArray: 'getDash',\n  drawFunc: 'sceneFunc',\n  getDrawFunc: 'getSceneFunc',\n  setDrawFunc: 'setSceneFunc',\n  drawHitFunc: 'hitFunc',\n  getDrawHitFunc: 'getHitFunc',\n  setDrawHitFunc: 'setHitFunc'\n});","map":{"version":3,"sources":["/Users/pbivrell/light/light/node_modules/konva/lib/Shape.js"],"names":["Konva","Transform","Util","Factory","Node","getNumberValidator","getNumberOrAutoValidator","getStringValidator","getBooleanValidator","getStringOrGradientValidator","_registerNode","PointerEvents","HAS_SHADOW","SHADOW_RGBA","patternImage","linearGradient","radialGradient","dummyContext","getDummyContext","createCanvasElement","getContext","shapes","_fillFunc","context","fill","_strokeFunc","stroke","_fillFuncHit","_strokeFuncHit","_clearHasShadowCache","_clearCache","_clearGetShadowRGBACache","_clearFillPatternCache","_clearLinearGradientCache","_clearRadialGradientCache","Shape","config","key","getRandomColor","colorKey","warn","getLayer","getCanvas","attrs","sceneFunc","hitFunc","_getCache","_hasShadow","shadowEnabled","shadowOpacity","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","__getFillPattern","fillPatternImage","ctx","pattern","createPattern","fillPatternRepeat","setTransform","tr","translate","fillPatternX","fillPatternY","rotate","getAngle","fillPatternRotation","scale","fillPatternScaleX","fillPatternScaleY","fillPatternOffsetX","fillPatternOffsetY","m","getMatrix","a","b","c","d","e","f","__getLinearGradient","colorStops","fillLinearGradientColorStops","start","fillLinearGradientStartPoint","end","fillLinearGradientEndPoint","grd","createLinearGradient","x","y","n","length","addColorStop","__getRadialGradient","fillRadialGradientColorStops","fillRadialGradientStartPoint","fillRadialGradientEndPoint","createRadialGradient","fillRadialGradientStartRadius","fillRadialGradientEndRadius","_getShadowRGBA","hasShadow","rgba","colorToRGBA","r","g","_calculate","fillEnabled","strokeEnabled","strokeWidth","strokeLinearGradientColorStops","width","hitStrokeWidth","hasStroke","point","stage","getStage","bufferHitCanvas","p","clear","drawHit","getImageData","Math","round","data","prototype","destroy","call","forceFill","_a","perfectDrawEnabled","hasFill","isTransparent","getAbsoluteOpacity","strokeForShadow","shadowForStrokeEnabled","val","size","_centroid","height","skipTransform","relativeTo","fillRect","getSelfRect","applyStroke","skipStroke","fillAndStrokeWidth","fillAndStrokeHeight","applyShadow","skipShadow","preWidth","abs","preHeight","blurRadius","roundingOffset","rect","min","_transformedRect","can","top","layer","canvas","cachedCanvas","_getCanvasCache","drawFunc","getSceneFunc","bufferCanvas","bufferContext","skipBuffer","isCache","cachingSelf","isVisible","save","getAbsoluteTransform","transform","_drawCachedSceneCanvas","restore","_useBufferCanvas","_applyLineJoin","o","ratio","pixelRatio","_applyShadow","_applyOpacity","_applyGlobalCompositeOperation","drawImage","_canvas","skipDragCheck","shouldDrawHit","hitCanvas","cachedHitCanvas","hit","_drawCachedHitCanvas","selfCache","alphaThreshold","sceneCanvas","_getCachedSceneCanvas","hitContext","hitWidth","getWidth","hitHeight","getHeight","hitImageData","hitData","len","rgbColorKey","i","alpha","_hexToRgb","putImageData","error","message","pointerId","hasPointerCapture","setPointerCapture","releaseCapture","nodeType","eventListeners","on","addGetterSetter","undefined","addComponentsGetterSetter","backCompat","dashArray","getDashArray","setDashArray","getDrawFunc","setDrawFunc","drawHitFunc","getDrawHitFunc","setDrawHitFunc"],"mappings":"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","sourcesContent":["import { Konva } from './Global.js';\nimport { Transform, Util } from './Util.js';\nimport { Factory } from './Factory.js';\nimport { Node } from './Node.js';\nimport { getNumberValidator, getNumberOrAutoValidator, getStringValidator, getBooleanValidator, getStringOrGradientValidator, } from './Validators.js';\nimport { _registerNode } from './Global.js';\nimport * as PointerEvents from './PointerEvents.js';\nvar HAS_SHADOW = 'hasShadow';\nvar SHADOW_RGBA = 'shadowRGBA';\nvar patternImage = 'patternImage';\nvar linearGradient = 'linearGradient';\nvar radialGradient = 'radialGradient';\nlet dummyContext;\nfunction getDummyContext() {\n    if (dummyContext) {\n        return dummyContext;\n    }\n    dummyContext = Util.createCanvasElement().getContext('2d');\n    return dummyContext;\n}\nexport const shapes = {};\nfunction _fillFunc(context) {\n    context.fill();\n}\nfunction _strokeFunc(context) {\n    context.stroke();\n}\nfunction _fillFuncHit(context) {\n    context.fill();\n}\nfunction _strokeFuncHit(context) {\n    context.stroke();\n}\nfunction _clearHasShadowCache() {\n    this._clearCache(HAS_SHADOW);\n}\nfunction _clearGetShadowRGBACache() {\n    this._clearCache(SHADOW_RGBA);\n}\nfunction _clearFillPatternCache() {\n    this._clearCache(patternImage);\n}\nfunction _clearLinearGradientCache() {\n    this._clearCache(linearGradient);\n}\nfunction _clearRadialGradientCache() {\n    this._clearCache(radialGradient);\n}\nexport class Shape extends Node {\n    constructor(config) {\n        super(config);\n        let key;\n        while (true) {\n            key = Util.getRandomColor();\n            if (key && !(key in shapes)) {\n                break;\n            }\n        }\n        this.colorKey = key;\n        shapes[key] = this;\n    }\n    getContext() {\n        Util.warn('shape.getContext() method is deprecated. Please do not use it.');\n        return this.getLayer().getContext();\n    }\n    getCanvas() {\n        Util.warn('shape.getCanvas() method is deprecated. Please do not use it.');\n        return this.getLayer().getCanvas();\n    }\n    getSceneFunc() {\n        return this.attrs.sceneFunc || this['_sceneFunc'];\n    }\n    getHitFunc() {\n        return this.attrs.hitFunc || this['_hitFunc'];\n    }\n    hasShadow() {\n        return this._getCache(HAS_SHADOW, this._hasShadow);\n    }\n    _hasShadow() {\n        return (this.shadowEnabled() &&\n            this.shadowOpacity() !== 0 &&\n            !!(this.shadowColor() ||\n                this.shadowBlur() ||\n                this.shadowOffsetX() ||\n                this.shadowOffsetY()));\n    }\n    _getFillPattern() {\n        return this._getCache(patternImage, this.__getFillPattern);\n    }\n    __getFillPattern() {\n        if (this.fillPatternImage()) {\n            var ctx = getDummyContext();\n            const pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || 'repeat');\n            if (pattern && pattern.setTransform) {\n                const tr = new Transform();\n                tr.translate(this.fillPatternX(), this.fillPatternY());\n                tr.rotate(Konva.getAngle(this.fillPatternRotation()));\n                tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());\n                tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());\n                const m = tr.getMatrix();\n                pattern.setTransform({\n                    a: m[0],\n                    b: m[1],\n                    c: m[2],\n                    d: m[3],\n                    e: m[4],\n                    f: m[5],\n                });\n            }\n            return pattern;\n        }\n    }\n    _getLinearGradient() {\n        return this._getCache(linearGradient, this.__getLinearGradient);\n    }\n    __getLinearGradient() {\n        var colorStops = this.fillLinearGradientColorStops();\n        if (colorStops) {\n            var ctx = getDummyContext();\n            var start = this.fillLinearGradientStartPoint();\n            var end = this.fillLinearGradientEndPoint();\n            var grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\n            for (var n = 0; n < colorStops.length; n += 2) {\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\n            }\n            return grd;\n        }\n    }\n    _getRadialGradient() {\n        return this._getCache(radialGradient, this.__getRadialGradient);\n    }\n    __getRadialGradient() {\n        var colorStops = this.fillRadialGradientColorStops();\n        if (colorStops) {\n            var ctx = getDummyContext();\n            var start = this.fillRadialGradientStartPoint();\n            var end = this.fillRadialGradientEndPoint();\n            var grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());\n            for (var n = 0; n < colorStops.length; n += 2) {\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\n            }\n            return grd;\n        }\n    }\n    getShadowRGBA() {\n        return this._getCache(SHADOW_RGBA, this._getShadowRGBA);\n    }\n    _getShadowRGBA() {\n        if (this.hasShadow()) {\n            var rgba = Util.colorToRGBA(this.shadowColor());\n            return ('rgba(' +\n                rgba.r +\n                ',' +\n                rgba.g +\n                ',' +\n                rgba.b +\n                ',' +\n                rgba.a * (this.shadowOpacity() || 1) +\n                ')');\n        }\n    }\n    hasFill() {\n        return this._calculate('hasFill', [\n            'fillEnabled',\n            'fill',\n            'fillPatternImage',\n            'fillLinearGradientColorStops',\n            'fillRadialGradientColorStops',\n        ], () => {\n            return (this.fillEnabled() &&\n                !!(this.fill() ||\n                    this.fillPatternImage() ||\n                    this.fillLinearGradientColorStops() ||\n                    this.fillRadialGradientColorStops()));\n        });\n    }\n    hasStroke() {\n        return this._calculate('hasStroke', [\n            'strokeEnabled',\n            'strokeWidth',\n            'stroke',\n            'strokeLinearGradientColorStops',\n        ], () => {\n            return (this.strokeEnabled() &&\n                this.strokeWidth() &&\n                !!(this.stroke() || this.strokeLinearGradientColorStops()));\n        });\n    }\n    hasHitStroke() {\n        const width = this.hitStrokeWidth();\n        if (width === 'auto') {\n            return this.hasStroke();\n        }\n        return this.strokeEnabled() && !!width;\n    }\n    intersects(point) {\n        var stage = this.getStage(), bufferHitCanvas = stage.bufferHitCanvas, p;\n        bufferHitCanvas.getContext().clear();\n        this.drawHit(bufferHitCanvas, null, true);\n        p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;\n        return p[3] > 0;\n    }\n    destroy() {\n        Node.prototype.destroy.call(this);\n        delete shapes[this.colorKey];\n        delete this.colorKey;\n        return this;\n    }\n    _useBufferCanvas(forceFill) {\n        var _a;\n        if (!this.getStage()) {\n            return false;\n        }\n        const perfectDrawEnabled = (_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : true;\n        if (!perfectDrawEnabled) {\n            return false;\n        }\n        const hasFill = forceFill || this.hasFill();\n        const hasStroke = this.hasStroke();\n        const isTransparent = this.getAbsoluteOpacity() !== 1;\n        if (hasFill && hasStroke && isTransparent) {\n            return true;\n        }\n        const hasShadow = this.hasShadow();\n        const strokeForShadow = this.shadowForStrokeEnabled();\n        if (hasFill && hasStroke && hasShadow && strokeForShadow) {\n            return true;\n        }\n        return false;\n    }\n    setStrokeHitEnabled(val) {\n        Util.warn('strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.');\n        if (val) {\n            this.hitStrokeWidth('auto');\n        }\n        else {\n            this.hitStrokeWidth(0);\n        }\n    }\n    getStrokeHitEnabled() {\n        if (this.hitStrokeWidth() === 0) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    getSelfRect() {\n        var size = this.size();\n        return {\n            x: this._centroid ? -size.width / 2 : 0,\n            y: this._centroid ? -size.height / 2 : 0,\n            width: size.width,\n            height: size.height,\n        };\n    }\n    getClientRect(config = {}) {\n        const skipTransform = config.skipTransform;\n        const relativeTo = config.relativeTo;\n        const fillRect = this.getSelfRect();\n        const applyStroke = !config.skipStroke && this.hasStroke();\n        const strokeWidth = (applyStroke && this.strokeWidth()) || 0;\n        const fillAndStrokeWidth = fillRect.width + strokeWidth;\n        const fillAndStrokeHeight = fillRect.height + strokeWidth;\n        const applyShadow = !config.skipShadow && this.hasShadow();\n        const shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;\n        const shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;\n        const preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);\n        const preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);\n        const blurRadius = (applyShadow && this.shadowBlur()) || 0;\n        const width = preWidth + blurRadius * 2;\n        const height = preHeight + blurRadius * 2;\n        let roundingOffset = 0;\n        if (Math.round(strokeWidth / 2) !== strokeWidth / 2) {\n            roundingOffset = 1;\n        }\n        const rect = {\n            width: width + roundingOffset,\n            height: height + roundingOffset,\n            x: -Math.round(strokeWidth / 2 + blurRadius) +\n                Math.min(shadowOffsetX, 0) +\n                fillRect.x,\n            y: -Math.round(strokeWidth / 2 + blurRadius) +\n                Math.min(shadowOffsetY, 0) +\n                fillRect.y,\n        };\n        if (!skipTransform) {\n            return this._transformedRect(rect, relativeTo);\n        }\n        return rect;\n    }\n    drawScene(can, top) {\n        var layer = this.getLayer(), canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.getSceneFunc(), hasShadow = this.hasShadow(), stage, bufferCanvas, bufferContext;\n        var skipBuffer = canvas.isCache;\n        var cachingSelf = top === this;\n        if (!this.isVisible() && !cachingSelf) {\n            return this;\n        }\n        if (cachedCanvas) {\n            context.save();\n            var m = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            this._drawCachedSceneCanvas(context);\n            context.restore();\n            return this;\n        }\n        if (!drawFunc) {\n            return this;\n        }\n        context.save();\n        if (this._useBufferCanvas() && !skipBuffer) {\n            stage = this.getStage();\n            bufferCanvas = stage.bufferCanvas;\n            bufferContext = bufferCanvas.getContext();\n            bufferContext.clear();\n            bufferContext.save();\n            bufferContext._applyLineJoin(this);\n            var o = this.getAbsoluteTransform(top).getMatrix();\n            bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n            drawFunc.call(this, bufferContext, this);\n            bufferContext.restore();\n            var ratio = bufferCanvas.pixelRatio;\n            if (hasShadow) {\n                context._applyShadow(this);\n            }\n            context._applyOpacity(this);\n            context._applyGlobalCompositeOperation(this);\n            context.drawImage(bufferCanvas._canvas, 0, 0, bufferCanvas.width / ratio, bufferCanvas.height / ratio);\n        }\n        else {\n            context._applyLineJoin(this);\n            if (!cachingSelf) {\n                var o = this.getAbsoluteTransform(top).getMatrix();\n                context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n                context._applyOpacity(this);\n                context._applyGlobalCompositeOperation(this);\n            }\n            if (hasShadow) {\n                context._applyShadow(this);\n            }\n            drawFunc.call(this, context, this);\n        }\n        context.restore();\n        return this;\n    }\n    drawHit(can, top, skipDragCheck = false) {\n        if (!this.shouldDrawHit(top, skipDragCheck)) {\n            return this;\n        }\n        var layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;\n        if (!this.colorKey) {\n            Util.warn('Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()');\n        }\n        if (cachedHitCanvas) {\n            context.save();\n            var m = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            this._drawCachedHitCanvas(context);\n            context.restore();\n            return this;\n        }\n        if (!drawFunc) {\n            return this;\n        }\n        context.save();\n        context._applyLineJoin(this);\n        const selfCache = this === top;\n        if (!selfCache) {\n            var o = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n        }\n        drawFunc.call(this, context, this);\n        context.restore();\n        return this;\n    }\n    drawHitFromCache(alphaThreshold = 0) {\n        var cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight(), hitImageData, hitData, len, rgbColorKey, i, alpha;\n        hitContext.clear();\n        hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);\n        try {\n            hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);\n            hitData = hitImageData.data;\n            len = hitData.length;\n            rgbColorKey = Util._hexToRgb(this.colorKey);\n            for (i = 0; i < len; i += 4) {\n                alpha = hitData[i + 3];\n                if (alpha > alphaThreshold) {\n                    hitData[i] = rgbColorKey.r;\n                    hitData[i + 1] = rgbColorKey.g;\n                    hitData[i + 2] = rgbColorKey.b;\n                    hitData[i + 3] = 255;\n                }\n                else {\n                    hitData[i + 3] = 0;\n                }\n            }\n            hitContext.putImageData(hitImageData, 0, 0);\n        }\n        catch (e) {\n            Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);\n        }\n        return this;\n    }\n    hasPointerCapture(pointerId) {\n        return PointerEvents.hasPointerCapture(pointerId, this);\n    }\n    setPointerCapture(pointerId) {\n        PointerEvents.setPointerCapture(pointerId, this);\n    }\n    releaseCapture(pointerId) {\n        PointerEvents.releaseCapture(pointerId, this);\n    }\n}\nShape.prototype._fillFunc = _fillFunc;\nShape.prototype._strokeFunc = _strokeFunc;\nShape.prototype._fillFuncHit = _fillFuncHit;\nShape.prototype._strokeFuncHit = _strokeFuncHit;\nShape.prototype._centroid = false;\nShape.prototype.nodeType = 'Shape';\n_registerNode(Shape);\nShape.prototype.eventListeners = {};\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva', _clearFillPatternCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva', _clearLinearGradientCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva', _clearRadialGradientCache);\nFactory.addGetterSetter(Shape, 'stroke', undefined, getStringOrGradientValidator());\nFactory.addGetterSetter(Shape, 'strokeWidth', 2, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillAfterStrokeEnabled', false);\nFactory.addGetterSetter(Shape, 'hitStrokeWidth', 'auto', getNumberOrAutoValidator());\nFactory.addGetterSetter(Shape, 'strokeHitEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'perfectDrawEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'shadowForStrokeEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'lineJoin');\nFactory.addGetterSetter(Shape, 'lineCap');\nFactory.addGetterSetter(Shape, 'sceneFunc');\nFactory.addGetterSetter(Shape, 'hitFunc');\nFactory.addGetterSetter(Shape, 'dash');\nFactory.addGetterSetter(Shape, 'dashOffset', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowColor', undefined, getStringValidator());\nFactory.addGetterSetter(Shape, 'shadowBlur', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowOpacity', 1, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'shadowOffset', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'shadowOffsetX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowOffsetY', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternImage');\nFactory.addGetterSetter(Shape, 'fill', undefined, getStringOrGradientValidator());\nFactory.addGetterSetter(Shape, 'fillPatternX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternY', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillLinearGradientColorStops');\nFactory.addGetterSetter(Shape, 'strokeLinearGradientColorStops');\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartRadius', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndRadius', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientColorStops');\nFactory.addGetterSetter(Shape, 'fillPatternRepeat', 'repeat');\nFactory.addGetterSetter(Shape, 'fillEnabled', true);\nFactory.addGetterSetter(Shape, 'strokeEnabled', true);\nFactory.addGetterSetter(Shape, 'shadowEnabled', true);\nFactory.addGetterSetter(Shape, 'dashEnabled', true);\nFactory.addGetterSetter(Shape, 'strokeScaleEnabled', true);\nFactory.addGetterSetter(Shape, 'fillPriority', 'color');\nFactory.addComponentsGetterSetter(Shape, 'fillPatternOffset', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillPatternOffsetX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternOffsetY', 0, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'fillPatternScale', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillPatternScaleX', 1, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternScaleY', 1, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientStartPoint', [\n    'x',\n    'y',\n]);\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientStartPoint', [\n    'x',\n    'y',\n]);\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointY', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientEndPoint', [\n    'x',\n    'y',\n]);\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientEndPoint', [\n    'x',\n    'y',\n]);\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointY', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientStartPoint', [\n    'x',\n    'y',\n]);\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientEndPoint', [\n    'x',\n    'y',\n]);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointY', 0);\nFactory.addGetterSetter(Shape, 'fillPatternRotation', 0);\nFactory.backCompat(Shape, {\n    dashArray: 'dash',\n    getDashArray: 'getDash',\n    setDashArray: 'getDash',\n    drawFunc: 'sceneFunc',\n    getDrawFunc: 'getSceneFunc',\n    setDrawFunc: 'setSceneFunc',\n    drawHitFunc: 'hitFunc',\n    getDrawHitFunc: 'getHitFunc',\n    setDrawHitFunc: 'setHitFunc',\n});\n"]},"metadata":{},"sourceType":"module"}